{"version":3,"sources":["../../src/services/otps.service.ts"],"sourcesContent":["// Import Service decorator from typedi for dependency injection\nimport { Service } from \"typedi\";\n// Import Sequelize Transaction type for transactional operations\nimport { Transaction } from \"sequelize\";\n// Import function to get database instance lazily\nimport { getDB } from \"@/database/db-lazy\";\n// Import OTP interface for OTP data structure\nimport { OTP } from \"@interfaces/otp.interface\";\n// Import custom HTTP exception for error handling\nimport { HttpException } from \"@exceptions/HttpException\";\n\n/**\n * Service class for OTP-related operations.\n * Handles OTP creation, validation, expiration, and status updates.\n */\n@Service()\nexport class OTPService {\n  /**\n   * Creates a new OTP for a user and stores it in the database.\n   * @param data - Object containing user_id and OTP type.\n   * @param validInMinutes - Number of minutes the OTP is valid for.\n   * @param transaction - Sequelize transaction for atomic operation.\n   * @returns Promise<OTP> - The created OTP object.\n   */\n  public async createOTP(data, validInMinutes: number, transaction: Transaction): Promise<OTP> {\n    // untuk generate otp || validInMinutes = mau valid berapa menit si otpnya\n    const key = Math.floor(Math.pow(10, 8 - 1) + Math.random() * 9 * Math.pow(10, 8 - 1)).toString();\n    const currentDateTime = new Date();\n    const expirationTime = new Date(currentDateTime.getTime() + validInMinutes * 60000);\n  \n    const otp = await (await getDB()).OTPs.create({\n      user_id: data.user_id,\n      key,\n      type: data.type,\n      status: \"AVAILABLE\",\n      expired_at: expirationTime,\n    }, { transaction });\n\n    return otp;\n  }\n\n  /**\n   * Finds and validates an OTP for a user, updating its status if used or expired.\n   * @param data - Object containing user_id, key, and type of OTP.\n   * @returns Promise<boolean> - True if OTP is valid and used.\n   * @throws HttpException if OTP is not valid or expired.\n   */\n  public async findOTP(data: { user_id: number, key: string, type: string }): Promise<boolean> {\n    const otp = await (await getDB()).OTPs.findOne({\n      where: {\n        user_id: data.user_id,\n        key: data.key,\n        status: \"AVAILABLE\",\n      }\n    });\n\n    if(!otp) {\n      throw new HttpException(false, 400, \"OTP is not valid\");\n    }\n\n    if(new Date(otp.expired_at) < new Date()) {\n      otp.status = \"EXPIRED\";\n      await otp.save();\n\n      throw new HttpException(false, 400, \"OTP is not valid\");\n    }\n\n    otp.status = \"USED\";\n    await otp.save();\n\n    return true;\n  }\n}"],"names":["OTPService","createOTP","data","validInMinutes","transaction","key","Math","floor","pow","random","toString","currentDateTime","Date","expirationTime","getTime","otp","getDB","OTPs","create","user_id","type","status","expired_at","findOTP","findOne","where","HttpException","save"],"mappings":";;;;+BAgBaA;;;eAAAA;;;wBAfW;wBAIF;+BAIQ;;;;;;;AAOvB,IAAA,AAAMA,aAAN,MAAMA;IAQX,MAAaC,UAAUC,IAAI,EAAEC,cAAsB,EAAEC,WAAwB,EAAgB;QAE3F,MAAMC,MAAMC,KAAKC,KAAK,CAACD,KAAKE,GAAG,CAAC,IAAI,IAAI,KAAKF,KAAKG,MAAM,KAAK,IAAIH,KAAKE,GAAG,CAAC,IAAI,IAAI,IAAIE,QAAQ;QAC9F,MAAMC,kBAAkB,IAAIC;QAC5B,MAAMC,iBAAiB,IAAID,KAAKD,gBAAgBG,OAAO,KAAKX,iBAAiB;QAE7E,MAAMY,MAAM,MAAM,AAAC,CAAA,MAAMC,IAAAA,aAAK,GAAC,EAAGC,IAAI,CAACC,MAAM,CAAC;YAC5CC,SAASjB,KAAKiB,OAAO;YACrBd;YACAe,MAAMlB,KAAKkB,IAAI;YACfC,QAAQ;YACRC,YAAYT;QACd,GAAG;YAAET;QAAY;QAEjB,OAAOW;IACT;IAQA,MAAaQ,QAAQrB,IAAoD,EAAoB;QAC3F,MAAMa,MAAM,MAAM,AAAC,CAAA,MAAMC,IAAAA,aAAK,GAAC,EAAGC,IAAI,CAACO,OAAO,CAAC;YAC7CC,OAAO;gBACLN,SAASjB,KAAKiB,OAAO;gBACrBd,KAAKH,KAAKG,GAAG;gBACbgB,QAAQ;YACV;QACF;QAEA,IAAG,CAACN,KAAK;YACP,MAAM,IAAIW,4BAAa,CAAC,OAAO,KAAK;QACtC;QAEA,IAAG,IAAId,KAAKG,IAAIO,UAAU,IAAI,IAAIV,QAAQ;YACxCG,IAAIM,MAAM,GAAG;YACb,MAAMN,IAAIY,IAAI;YAEd,MAAM,IAAID,4BAAa,CAAC,OAAO,KAAK;QACtC;QAEAX,IAAIM,MAAM,GAAG;QACb,MAAMN,IAAIY,IAAI;QAEd,OAAO;IACT;AACF"}