{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["import { compare, hash } from \"bcrypt\";\nimport { sign } from \"jsonwebtoken\";\nimport { Service } from \"typedi\";\nimport { Transaction } from \"sequelize\";\n\nimport { SECRET_KEY } from \"@config/index\";\nimport { getDB } from \"@/database/db-lazy\";\n\nimport { OTPService } from \"@services/otps.service\";\n\nimport { User } from \"@interfaces/user.interface\";\nimport { UserRole } from \"@interfaces/authentication/user-role.interface\";\nimport { UserSession } from \"@interfaces/user-session.interface\";\nimport { UserAgent } from \"@interfaces/common/useragent.interface\";\nimport { DataStoredInToken, TokenPayload } from \"@interfaces/authentication/token.interface\";\n\nimport { CreateUserDto } from \"@dtos/users.dto\";\nimport { HttpException } from \"@exceptions/HttpException\";\nimport { sendEmailOTP } from \"@utils/mailer\";\n\nconst createAccessToken = (user: User, userSession: UserSession): TokenPayload => {\n  const dataStoredInToken: DataStoredInToken = { uid: user.uuid, sid: userSession.uuid };\n  const expiresIn: number = 60 * 60 * 60;\n\n  return { expiresIn: expiresIn, token: sign(dataStoredInToken, SECRET_KEY, { expiresIn }) };\n};  \n\nconst createCookie = (TokenPayload: TokenPayload): string => {\n  return `Authorization=${TokenPayload.token}; HttpOnly; Max-Age=${TokenPayload.expiresIn};`;\n};\n\n@Service()\nexport class AuthService {\n  public async signup(userData: CreateUserDto): Promise<{ uuid: string, email: string }> {\n    const transaction = await (await getDB()).sequelize.transaction();\n\n    try {\n      const existingUser = await (await getDB()).Users.findOne({ where: { email: userData.email }, transaction });\n\n      if (existingUser) {\n        throw new HttpException(false, 409, `This email ${userData.email} already exists`);\n      }\n  \n      const hashedPassword = await hash(userData.password, 10);\n  \n      const createUser = await (await getDB()).Users.create(\n        { ...userData, password: hashedPassword },\n        { transaction }\n      );\n  \n      const roleId = await this.getRoleId(\"USER\");\n      await this.asignUserRole(createUser.pk, roleId, transaction);\n      \n      const validInMinutes = 10;\n      const otp = await new OTPService().createOTP({\n        user_id: createUser.pk,\n        type: \"EMAIL_VERIFICATION\",\n      }, validInMinutes, transaction);\n      \n      await sendEmailOTP({\n        email: createUser.email,\n        full_name: createUser.full_name,\n        otp: otp.key,\n        expiration_time: validInMinutes,\n      });\n\n      await transaction.commit();\n      \n      return { uuid: createUser.uuid, email: createUser.email };\n    } catch (error) {\n      await transaction.rollback();\n      throw error; \n    }\n  }\n\n  public async login(userData: CreateUserDto, userAgent: UserAgent): Promise<{ cookie: string; accessToken: string }> {\n    const findUser: User = await (await getDB()).Users.findOne({ attributes: [\"pk\", \"uuid\", \"password\", \"email_verified_at\"], where: { email: userData.email } });\n    if (!findUser) throw new HttpException(false, 409, `This email ${userData.email} was not found`);\n\n    const isPasswordMatching: boolean = await compare(userData.password, findUser.password);\n    if (!isPasswordMatching) throw new HttpException(false, 409, \"Password not matching\");\n\n    if(!findUser.email_verified_at) throw new HttpException(false, 400, \"Email is not verified\");\n    \n    const sessionData = await this.createUserSession({ \n      pk: findUser.pk, useragent: userAgent.source, ip_address: userAgent.ip_address\n    });\n\n    const TokenPayload = createAccessToken(findUser, sessionData);\n    const { token } = TokenPayload;\n\n    const cookie = createCookie(TokenPayload);\n    return { cookie, accessToken: token };\n  }\n\n  public async logout(userData: User, userSessionId: string): Promise<boolean> {\n    const findUser: User = await (await getDB()).Users.findOne({ where: { pk: userData.pk } });\n    if (!findUser) throw new HttpException(false, 409, \"User doesn't exist\");\n\n    const logout = await this.logoutSessionActive({ uid: findUser.uuid, sid: userSessionId });\n    return logout;\n  }\n\n  public async checkSessionActive(session_id: string): Promise<UserSession> {\n    const userSession = await (await getDB()).UsersSessions.findOne({ \n      where: { uuid: session_id, status: \"ACTIVE\" },\n      include: [{ model: (await getDB()).Users, as: \"user\" }]\n    });\n\n    return userSession || null;\n  };\n\n  public async getUserRoles(user_id: number): Promise<UserRole[]> {\n    const roles = await (await getDB()).UsersRoles.findAll({ \n      where: { user_id },\n      include: [{ model: (await getDB()).Roles, as: \"role\" }]\n    });\n\n    return roles;\n  };\n\n  public async logoutSessionActive(data: { uid: string, sid: string }): Promise<boolean> {\n    const userSession = await (await getDB()).UsersSessions.findOne({ \n      where: { uuid: data.sid, status: \"ACTIVE\" },\n      include: { model: (await getDB()).Users, as: \"user\" }\n    });\n  \n    if (userSession) {\n      userSession.status = \"LOGOUT\";\n      await userSession.save();\n      return true;\n    } else {\n      return true;\n    }\n  }\n\n  public async createUserSession(data: { pk: number, useragent: string, ip_address: string }): Promise<UserSession> {\n    const session = await (await getDB()).UsersSessions.create({\n      user_id: data.pk,\n      useragent: data.useragent,\n      ip_address: data.ip_address,\n      status: \"ACTIVE\"\n    });\n\n    return session;\n  };\n\n  private async getRoleId(name: string): Promise<number> {\n    const role = await (await getDB()).Roles.findOne({ where: { name }});\n    return role.pk;\n  }\n\n  private async asignUserRole(user_id: number, role_id: number, transaction: Transaction): Promise<UserRole> {\n    const role = await (await getDB()).UsersRoles.create({ user_id, role_id }, { transaction });\n    return role;\n  }\n\n  public async verifyEmail(user_uuid: string, otp: string): Promise<{ email: string }> {\n    const user = await (await getDB()).Users.findOne({ attributes: [\"pk\"], where: { uuid: user_uuid } } );\n    if(!user) throw new HttpException(false, 400, \"Invalid UUID\");\n    \n    const valid = await new OTPService().findOTP({ \n      user_id: user.pk, key: otp, type: \"EMAIL_VERIFICATION\"\n    });\n\n    if(valid) {\n      user.email_verified_at = new Date();\n\n      await user.save();\n    }\n\n    return { email: user.email };\n  };\n}"],"names":["AuthService","createAccessToken","user","userSession","dataStoredInToken","uid","uuid","sid","expiresIn","token","sign","SECRET_KEY","createCookie","TokenPayload","signup","userData","transaction","getDB","sequelize","existingUser","Users","findOne","where","email","HttpException","hashedPassword","hash","password","createUser","create","roleId","getRoleId","asignUserRole","pk","validInMinutes","otp","OTPService","createOTP","user_id","type","sendEmailOTP","full_name","key","expiration_time","commit","error","rollback","login","userAgent","findUser","attributes","isPasswordMatching","compare","email_verified_at","sessionData","createUserSession","useragent","source","ip_address","cookie","accessToken","logout","userSessionId","logoutSessionActive","checkSessionActive","session_id","UsersSessions","status","include","model","as","getUserRoles","roles","UsersRoles","findAll","Roles","data","save","session","name","role","role_id","verifyEmail","user_uuid","valid","findOTP","Date"],"mappings":"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"}