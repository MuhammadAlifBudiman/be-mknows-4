{"version":3,"sources":["../../src/services/auth.service.ts"],"sourcesContent":["// Import bcrypt functions for password hashing and comparison\nimport { compare, hash } from \"bcrypt\";\n// Import JWT sign function for token creation\nimport { sign } from \"jsonwebtoken\";\n// Import Service decorator from typedi for dependency injection\nimport { Service } from \"typedi\";\n// Import Sequelize Transaction type for transactional operations\nimport { Transaction } from \"sequelize\";\n// Import secret key for JWT signing\nimport { SECRET_KEY } from \"@config/index\";\n// Import function to get database instance lazily\nimport { getDB } from \"@/database/db-lazy\";\n// Import OTP service for handling OTP logic\nimport { OTPService } from \"@services/otps.service\";\n// Import interfaces for user, user role, session, user agent, and token payloads\nimport { User } from \"@interfaces/user.interface\";\nimport { UserRole } from \"@interfaces/authentication/user-role.interface\";\nimport { UserSession } from \"@interfaces/user-session.interface\";\nimport { UserAgent } from \"@interfaces/common/useragent.interface\";\nimport { DataStoredInToken, TokenPayload } from \"@interfaces/authentication/token.interface\";\n// Import DTO for user creation\nimport { CreateUserDto } from \"@dtos/users.dto\";\n// Import custom HTTP exception for error handling\nimport { HttpException } from \"@exceptions/HttpException\";\n// Import utility for sending OTP emails\nimport { sendEmailOTP } from \"@utils/mailer\";\n\n/**\n * Creates a JWT access token for a user and session.\n * @param user - The user object.\n * @param userSession - The user session object.\n * @returns TokenPayload - The token and its expiration.\n */\nconst createAccessToken = (user: User, userSession: UserSession): TokenPayload => {\n  const dataStoredInToken: DataStoredInToken = { uid: user.uuid, sid: userSession.uuid };\n  const expiresIn: number = 60 * 60 * 60;\n\n  return { expiresIn: expiresIn, token: sign(dataStoredInToken, SECRET_KEY, { expiresIn }) };\n};  \n\n/**\n * Creates an HTTP-only cookie string for the access token.\n * @param TokenPayload - The token payload object.\n * @returns string - The cookie string.\n */\nconst createCookie = (TokenPayload: TokenPayload): string => {\n  return `Authorization=${TokenPayload.token}; HttpOnly; Max-Age=${TokenPayload.expiresIn};`;\n};\n\n/**\n * Service class for authentication-related operations.\n * Handles signup, login, logout, session management, role assignment, and email verification.\n */\n@Service()\nexport class AuthService {\n  /**\n   * Registers a new user, assigns role, and sends OTP for email verification.\n   * @param userData - DTO containing user registration fields.\n   * @returns Promise<{ uuid: string, email: string, otp?: string }>\n   * @throws HttpException if email already exists or other errors occur.\n   */\n  public async signup(userData: CreateUserDto): Promise<{ uuid: string, email: string, otp?: string }> {\n    const transaction = await (await getDB()).sequelize.transaction();\n\n    try {\n      const existingUser = await (await getDB()).Users.findOne({ where: { email: userData.email }, transaction });\n\n      if (existingUser) {\n        throw new HttpException(false, 409, `This email ${userData.email} already exists`);\n      }\n  \n      const hashedPassword = await hash(userData.password, 10);\n  \n      const createUser = await (await getDB()).Users.create(\n        { ...userData, password: hashedPassword },\n        { transaction }\n      );\n  \n      const roleId = await this.getRoleId(\"USER\");\n      await this.asignUserRole(createUser.pk, roleId, transaction);\n      \n      const validInMinutes = 10;\n      const otp = await new OTPService().createOTP({\n        user_id: createUser.pk,\n        type: \"EMAIL_VERIFICATION\",\n      }, validInMinutes, transaction);\n      \n      await sendEmailOTP({\n        email: createUser.email,\n        full_name: createUser.full_name,\n        otp: otp.key,\n        expiration_time: validInMinutes,\n      });\n\n      await transaction.commit();\n      \n      // Only include OTP key in response in development or test\n      if (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test') {\n        return { uuid: createUser.uuid, email: createUser.email, otp: otp.key };\n      }\n      return { uuid: createUser.uuid, email: createUser.email };\n    } catch (error) {\n      await transaction.rollback();\n      throw error; \n    }\n  }\n\n  /**\n   * Authenticates a user and creates a session, returning cookie and access token.\n   * @param userData - DTO containing login credentials.\n   * @param userAgent - User agent information for session.\n   * @returns Promise<{ cookie: string; accessToken: string }>\n   * @throws HttpException if user not found, password mismatch, or email not verified.\n   */\n  public async login(userData: CreateUserDto, userAgent: UserAgent): Promise<{ cookie: string; accessToken: string }> {\n    const findUser: User = await (await getDB()).Users.findOne({ attributes: [\"pk\", \"uuid\", \"password\", \"email_verified_at\"], where: { email: userData.email } });\n    if (!findUser) throw new HttpException(false, 409, `This email ${userData.email} was not found`);\n\n    const isPasswordMatching: boolean = await compare(userData.password, findUser.password);\n    if (!isPasswordMatching) throw new HttpException(false, 409, \"Password not matching\");\n\n    if(!findUser.email_verified_at) throw new HttpException(false, 400, \"Email is not verified\");\n    \n    const sessionData = await this.createUserSession({ \n      pk: findUser.pk, useragent: userAgent.source, ip_address: userAgent.ip_address\n    });\n\n    const TokenPayload = createAccessToken(findUser, sessionData);\n    const { token } = TokenPayload;\n\n    const cookie = createCookie(TokenPayload);\n    return { cookie, accessToken: token };\n  }\n\n  /**\n   * Logs out a user by ending their active session.\n   * @param userData - The user object.\n   * @param userSessionId - The session UUID to log out.\n   * @returns Promise<boolean> - True if logout is successful.\n   * @throws HttpException if user doesn't exist.\n   */\n  public async logout(userData: User, userSessionId: string): Promise<boolean> {\n    const findUser: User = await (await getDB()).Users.findOne({ where: { pk: userData.pk } });\n    if (!findUser) throw new HttpException(false, 409, \"User doesn't exist\");\n\n    const logout = await this.logoutSessionActive({ uid: findUser.uuid, sid: userSessionId });\n    return logout;\n  }\n\n  /**\n   * Checks if a session is active by its UUID.\n   * @param session_id - The session UUID.\n   * @returns Promise<UserSession> - The session object or null.\n   */\n  public async checkSessionActive(session_id: string): Promise<UserSession> {\n    const userSession = await (await getDB()).UsersSessions.findOne({ \n      where: { uuid: session_id, status: \"ACTIVE\" },\n      include: [{ model: (await getDB()).Users, as: \"user\" }]\n    });\n\n    return userSession || null;\n  };\n\n  /**\n   * Retrieves all roles assigned to a user by user ID.\n   * @param user_id - The user's primary key.\n   * @returns Promise<UserRole[]> - Array of user roles.\n   */\n  public async getUserRoles(user_id: number): Promise<UserRole[]> {\n    const roles = await (await getDB()).UsersRoles.findAll({ \n      where: { user_id },\n      include: [{ model: (await getDB()).Roles, as: \"role\" }]\n    });\n\n    return roles;\n  };\n\n  /**\n   * Logs out an active session by updating its status.\n   * @param data - Object containing user UUID and session UUID.\n   * @returns Promise<boolean> - True if logout is successful.\n   */\n  public async logoutSessionActive(data: { uid: string, sid: string }): Promise<boolean> {\n    const userSession = await (await getDB()).UsersSessions.findOne({ \n      where: { uuid: data.sid, status: \"ACTIVE\" },\n      include: { model: (await getDB()).Users, as: \"user\" }\n    });\n  \n    if (userSession) {\n      userSession.status = \"LOGOUT\";\n      await userSession.save();\n      return true;\n    } else {\n      return true;\n    }\n  }\n\n  /**\n   * Creates a new user session with user agent and IP address.\n   * @param data - Object containing user PK, user agent, and IP address.\n   * @returns Promise<UserSession> - The created session object.\n   */\n  public async createUserSession(data: { pk: number, useragent: string, ip_address: string }): Promise<UserSession> {\n    const session = await (await getDB()).UsersSessions.create({\n      user_id: data.pk,\n      useragent: data.useragent,\n      ip_address: data.ip_address,\n      status: \"ACTIVE\"\n    });\n\n    return session;\n  };\n\n  /**\n   * Retrieves the role ID by role name.\n   * @param name - The name of the role.\n   * @returns Promise<number> - The role's primary key.\n   */\n  private async getRoleId(name: string): Promise<number> {\n    const role = await (await getDB()).Roles.findOne({ where: { name }});\n    return role.pk;\n  }\n\n  /**\n   * Assigns a role to a user within a transaction.\n   * @param user_id - The user's primary key.\n   * @param role_id - The role's primary key.\n   * @param transaction - The Sequelize transaction object.\n   * @returns Promise<UserRole> - The created user role object.\n   */\n  private async asignUserRole(user_id: number, role_id: number, transaction: Transaction): Promise<UserRole> {\n    const role = await (await getDB()).UsersRoles.create({ user_id, role_id }, { transaction });\n    return role;\n  }\n\n  /**\n   * Verifies a user's email using OTP.\n   * @param user_uuid - The user's UUID.\n   * @param otp - The OTP key.\n   * @returns Promise<{ email: string }> - The verified email.\n   * @throws HttpException if UUID or OTP is invalid.\n   */\n  public async verifyEmail(user_uuid: string, otp: string): Promise<{ email: string }> {\n    const user = await (await getDB()).Users.findOne({ attributes: [\"pk\"], where: { uuid: user_uuid } } );\n    if(!user) throw new HttpException(false, 400, \"Invalid UUID\");\n    \n    const valid = await new OTPService().findOTP({ \n      user_id: user.pk, key: otp, type: \"EMAIL_VERIFICATION\"\n    });\n\n    if(valid) {\n      user.email_verified_at = new Date();\n\n      await user.save();\n    }\n\n    return { email: user.email };\n  };\n\n  /**\n   * Assigns a role to a user by UUID and role name, handling transaction and duplicate assignment.\n   * @param user_uuid - The user's UUID.\n   * @param role - The role name to assign.\n   * @returns Promise<{ user_role: string }> - The assigned role name.\n   * @throws HttpException if user or role not found, or assignment fails.\n   */\n  public async assignRoleToUser(user_uuid: string, role: string): Promise<{ user_role: string }> {\n    const db = await getDB();\n    const transaction = await db.sequelize.transaction();\n\n    try {\n      const user = await db.Users.findOne({ attributes: [\"pk\"], where: { uuid: user_uuid } });\n      if (!user) {\n        throw new HttpException(false, 404, \"User not found\");\n      }\n      const roleRecord = await db.Roles.findOne({ where: { name: role } });\n\n      if (!roleRecord) {\n        throw new HttpException(false, 404, `Role '${role}' not found`);\n      }\n\n      // Check if user already has this role\n      const existingUserRole = await db.UsersRoles.findOne({ where: { user_id: user.pk, role_id: roleRecord.pk } });\n      if (existingUserRole) {\n        await transaction.rollback();\n        return { user_role: roleRecord.name }; // Already assigned, return success\n      }\n\n      // Assign new role\n      await this.asignUserRole(user.pk, roleRecord.pk, transaction);\n      await transaction.commit();\n\n      const userRole = await db.UsersRoles.findOne({ where: { user_id: user.pk, role_id: roleRecord.pk }, attributes: [\"role_id\"] });\n      if (!userRole) {\n        throw new HttpException(false, 500, \"Failed to assign role to user\");\n      }\n\n      // Return the assigned role name\n      userRole.name = roleRecord.name; // Add name to the userRole object for response\n\n      return { user_role: userRole.name };\n    }catch (error){\n      await transaction.rollback();\n      throw error;\n    }\n  }\n}"],"names":["AuthService","createAccessToken","user","userSession","dataStoredInToken","uid","uuid","sid","expiresIn","token","sign","SECRET_KEY","createCookie","TokenPayload","signup","userData","transaction","getDB","sequelize","existingUser","Users","findOne","where","email","HttpException","hashedPassword","hash","password","createUser","create","roleId","getRoleId","asignUserRole","pk","validInMinutes","otp","OTPService","createOTP","user_id","type","sendEmailOTP","full_name","key","expiration_time","commit","process","env","NODE_ENV","error","rollback","login","userAgent","findUser","attributes","isPasswordMatching","compare","email_verified_at","sessionData","createUserSession","useragent","source","ip_address","cookie","accessToken","logout","userSessionId","logoutSessionActive","checkSessionActive","session_id","UsersSessions","status","include","model","as","getUserRoles","roles","UsersRoles","findAll","Roles","data","save","session","name","role","role_id","verifyEmail","user_uuid","valid","findOTP","Date","assignRoleToUser","db","roleRecord","existingUserRole","user_role","userRole"],"mappings":"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"}