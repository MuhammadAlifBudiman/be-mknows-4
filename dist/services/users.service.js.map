{"version":3,"sources":["../../src/services/users.service.ts"],"sourcesContent":["import { hash } from \"bcrypt\";\nimport { Service } from \"typedi\";\nimport { getDB } from \"@/database/db-lazy\";\nimport { CreateUserDto } from \"@dtos/users.dto\";\nimport { HttpException } from \"@/exceptions/HttpException\";\nimport { User } from \"@interfaces/user.interface\";\n\n@Service()\nexport class UserService {\n  public async findAllUser(): Promise<User[]> {\n    const db = await getDB();\n    const allUser: User[] = await db.Users.findAll();\n    return allUser;\n  }\n\n  public async findUserById(userId: number): Promise<User> {\n    const db = await getDB();\n    const findUser: User = await db.Users.findByPk(userId);\n    if (!findUser) throw new HttpException(false, 409, \"User doesn't exist\");\n    return findUser;\n  }\n\n  public async createUser(userData: CreateUserDto): Promise<User> {\n    const db = await getDB();\n    const findUser: User = await db.Users.findOne({ where: { email: userData.email } });\n    if (findUser) throw new HttpException(false, 409, `This email ${userData.email} already exists`);\n    const hashedPassword = await hash(userData.password, 10);\n    const createUserData: User = await db.Users.create({ ...userData, password: hashedPassword });\n    return createUserData;\n  }\n\n  public async updateUser(userId: number, userData: CreateUserDto): Promise<User> {\n    const db = await getDB();\n    const findUser: User = await db.Users.findByPk(userId);\n    if (!findUser) throw new HttpException(false, 409, \"User doesn't exist\");\n    const hashedPassword = await hash(userData.password, 10);\n    await db.Users.update({ ...userData, password: hashedPassword }, { where: { pk: userId } });\n    const updateUser: User = await db.Users.findByPk(userId);\n    return updateUser;\n  }\n\n  public async deleteUser(userId: number): Promise<User> {\n    const db = await getDB();\n    const findUser: User = await db.Users.findByPk(userId);\n    if (!findUser) throw new HttpException(false, 409, \"User doesn't exist\");\n    await db.Users.destroy({ where: { pk: userId } });\n    return findUser;\n  }\n}"],"names":["UserService","findAllUser","db","getDB","allUser","Users","findAll","findUserById","userId","findUser","findByPk","HttpException","createUser","userData","findOne","where","email","hashedPassword","hash","password","createUserData","create","updateUser","update","pk","deleteUser","destroy"],"mappings":";;;;+BAQaA;;;eAAAA;;;wBARQ;wBACG;wBACF;+BAEQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIvB,IAAA,AAAMA,cAAN,MAAMA;IACX,MAAaC,cAA+B;QAC1C,MAAMC,KAAK,MAAMC,IAAAA,aAAK;QACtB,MAAMC,UAAkB,MAAMF,GAAGG,KAAK,CAACC,OAAO;QAC9C,OAAOF;IACT;IAEA,MAAaG,aAAaC,MAAc,EAAiB;QACvD,MAAMN,KAAK,MAAMC,IAAAA,aAAK;QACtB,MAAMM,WAAiB,MAAMP,GAAGG,KAAK,CAACK,QAAQ,CAACF;QAC/C,IAAI,CAACC,UAAU,MAAM,IAAIE,4BAAa,CAAC,OAAO,KAAK;QACnD,OAAOF;IACT;IAEA,MAAaG,WAAWC,QAAuB,EAAiB;QAC9D,MAAMX,KAAK,MAAMC,IAAAA,aAAK;QACtB,MAAMM,WAAiB,MAAMP,GAAGG,KAAK,CAACS,OAAO,CAAC;YAAEC,OAAO;gBAAEC,OAAOH,SAASG,KAAK;YAAC;QAAE;QACjF,IAAIP,UAAU,MAAM,IAAIE,4BAAa,CAAC,OAAO,KAAK,CAAC,WAAW,EAAEE,SAASG,KAAK,CAAC,eAAe,CAAC;QAC/F,MAAMC,iBAAiB,MAAMC,IAAAA,YAAI,EAACL,SAASM,QAAQ,EAAE;QACrD,MAAMC,iBAAuB,MAAMlB,GAAGG,KAAK,CAACgB,MAAM,CAAC,wCAAKR;YAAUM,UAAUF;;QAC5E,OAAOG;IACT;IAEA,MAAaE,WAAWd,MAAc,EAAEK,QAAuB,EAAiB;QAC9E,MAAMX,KAAK,MAAMC,IAAAA,aAAK;QACtB,MAAMM,WAAiB,MAAMP,GAAGG,KAAK,CAACK,QAAQ,CAACF;QAC/C,IAAI,CAACC,UAAU,MAAM,IAAIE,4BAAa,CAAC,OAAO,KAAK;QACnD,MAAMM,iBAAiB,MAAMC,IAAAA,YAAI,EAACL,SAASM,QAAQ,EAAE;QACrD,MAAMjB,GAAGG,KAAK,CAACkB,MAAM,CAAC,wCAAKV;YAAUM,UAAUF;YAAkB;YAAEF,OAAO;gBAAES,IAAIhB;YAAO;QAAE;QACzF,MAAMc,aAAmB,MAAMpB,GAAGG,KAAK,CAACK,QAAQ,CAACF;QACjD,OAAOc;IACT;IAEA,MAAaG,WAAWjB,MAAc,EAAiB;QACrD,MAAMN,KAAK,MAAMC,IAAAA,aAAK;QACtB,MAAMM,WAAiB,MAAMP,GAAGG,KAAK,CAACK,QAAQ,CAACF;QAC/C,IAAI,CAACC,UAAU,MAAM,IAAIE,4BAAa,CAAC,OAAO,KAAK;QACnD,MAAMT,GAAGG,KAAK,CAACqB,OAAO,CAAC;YAAEX,OAAO;gBAAES,IAAIhB;YAAO;QAAE;QAC/C,OAAOC;IACT;AACF"}