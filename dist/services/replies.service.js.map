{"version":3,"sources":["../../src/services/replies.service.ts"],"sourcesContent":["// Import function to get database instance lazily\nimport { getDB } from \"@/database/db-lazy\";\n// Import DTOs for creating and updating replies\nimport { CreateReplyDto, UpdateReplyDto } from \"@/dtos/replies.dto\";\n// Import custom HTTP exception for error handling\nimport { HttpException } from \"@exceptions/HttpException\";\n// Import interfaces for reply and parsed reply structure\nimport { CommentReply, CommentReplyParsed } from \"@/interfaces/comment.interface\";\n// Import Service decorator from typedi for dependency injection\nimport { Service } from \"typedi\";\n// Import CommentReplyModel for ORM operations on replies table\nimport { CommentReplyModel } from \"@/models/articles_replies.model\";\n\n/**\n * Service class for reply-related operations.\n * Handles CRUD, likes, and parsing logic for replies.\n */\n@Service()\nexport class ReplyService {\n  /**\n   * Parses a CommentReplyModel instance into a CommentReplyParsed object.\n   * @param reply - The CommentReplyModel instance.\n   * @returns CommentReplyParsed - The parsed reply object.\n   */\n  private replyParsed(reply: CommentReplyModel): CommentReplyParsed {\n    return {\n      uuid: reply.uuid,\n      reply: reply.reply,\n      comment: {\n        uuid: reply.comment.uuid,\n        comment: reply.comment.comment,\n      },\n      author: {\n        uuid: reply.author.uuid,\n        full_name: reply.author.full_name || null,\n        avatar: reply.author.avatar?.uuid || null, \n      },\n      likes: reply.likes || 0,\n      };\n    }\n\n  /**\n   * Retrieves all replies with their like counts.\n   * @returns Promise<{ replies: CommentReplyParsed[] }> - Array of parsed replies.\n   */\n  public async getReplies(): Promise<{ replies: CommentReplyParsed[] }> {\n    const DB = await getDB();\n    const reply = await DB.CommentsReplies.findAll({});\n\n    const likeCountPromises = reply.map(reply => {\n      return DB.CommentsRepliesLikes.count({\n        where: { reply_id: reply.pk }\n      });\n    });\n\n    const likesCount = await Promise.all(likeCountPromises);\n\n    reply.forEach((reply, index) => {\n      reply.likes = likesCount[index];\n    });\n\n    const transformedReplies = reply.map(reply => this.replyParsed(reply));\n    return { replies: transformedReplies };\n  }\n\n  /**\n   * Retrieves replies for a specific comment by its UUID.\n   * @param comment_id - The UUID of the comment.\n   * @returns Promise<{ replies: CommentReplyParsed[] }> - Array of parsed replies.\n   * @throws HttpException if comment or replies are not found.\n   */\n  public async getRepliesByComment(comment_id: string): Promise<{ replies: CommentReplyParsed[] }> {\n    const DB = await getDB();\n    const comment = await DB.ArticlesComments.findOne({ where: { uuid: comment_id }, attributes: [\"pk\"] });\n    if(!comment) {\n      throw new HttpException(false, 404, \"Comment is not found\");\n    }\n    const replies = await DB.CommentsReplies.findAll({ where: { comment_id: comment.pk } });\n    if(!replies) {\n      throw new HttpException(false, 404, \"Reply is not found\");\n    }\n    const likeCountPromises = replies.map(reply => {\n      return DB.CommentsRepliesLikes.count({\n        where: { reply_id: reply.pk }\n      });\n    });\n\n    const likesCount = await Promise.all(likeCountPromises);\n\n    replies.forEach((reply, index) => {\n      reply.likes = likesCount[index];\n    });\n\n    const transformedReplies = replies.map(reply => this.replyParsed(reply));\n    return { replies: transformedReplies };\n  }\n\n  /**\n   * Retrieves a single reply by its UUID.\n   * @param reply_id - The UUID of the reply.\n   * @returns Promise<CommentReplyParsed> - The parsed reply object.\n   * @throws HttpException if reply is not found.\n   */\n  public async getReplyById(reply_id: string): Promise<CommentReplyParsed> {\n    const DB = await getDB();\n    const reply = await DB.CommentsReplies.findOne({ where: { uuid: reply_id } });\n    if (!reply) {\n      throw new HttpException(false, 400, \"Reply is not found\");\n    }\n\n    const likeCount = await DB.CommentsRepliesLikes.count({\n      where: { reply_id: reply.pk }\n    });\n\n    reply.likes = likeCount;\n\n    const response = this.replyParsed(reply);\n    return response;\n  }\n\n  /**\n   * Creates a new reply for a comment and author.\n   * @param comment_id - The UUID of the comment.\n   * @param author_id - The author's user ID.\n   * @param data - DTO containing reply creation fields.\n   * @returns Promise<CommentReplyParsed> - The created reply object.\n   */\n  public async createReply(comment_id: string, author_id: number, data: CreateReplyDto): Promise<CommentReplyParsed> {\n    const DB = await getDB();\n    const comment = await DB.ArticlesComments.findOne({ where: { uuid: comment_id }, attributes: [\"pk\"] });\n    const reply = await DB.CommentsReplies.create({ comment_id: comment.pk, author_id, ...data });\n    delete reply.dataValues.pk;\n\n    return this.getReplyById(reply.uuid);\n  }\n\n  /**\n   * Updates an existing reply by its UUID.\n   * @param reply_id - The UUID of the reply.\n   * @param data - DTO containing reply update fields.\n   * @returns Promise<CommentReplyParsed> - The updated reply object.\n   * @throws HttpException if no fields are provided.\n   */\n  public async updateReply(reply_id: string, data: UpdateReplyDto): Promise<CommentReplyParsed> {\n    const DB = await getDB();\n    const updatedData: any = {};\n    \n    if (data.reply) updatedData.reply = data.reply;\n\n    if (Object.keys(updatedData).length === 0) {\n      throw new HttpException(false, 400, \"Some field is required\");\n    }\n\n    if (Object.keys(updatedData).length > 0) {\n      await DB.CommentsReplies.update(updatedData, {\n        where: { uuid: reply_id },\n        returning: true,\n      });\n    }\n    \n\n    return this.getReplyById(reply_id);\n  }\n\n  /**\n   * Deletes a reply and all its related likes.\n   * @param reply_id - The UUID of the reply.\n   * @returns Promise<boolean> - True if deletion is successful.\n   * @throws HttpException if reply is not found.\n   */\n  public async deleteReply(reply_id: string): Promise<boolean> {\n    const DB = await getDB();\n    const reply = await DB.CommentsReplies.findOne({ where: { uuid: reply_id }});\n\n    if(!reply) {\n        throw new HttpException(false, 400, \"Reply is not found\");\n    }\n\n    const transaction = await DB.sequelize.transaction();\n    try {\n      await reply.destroy({ transaction });\n\n      await Promise.all([\n        DB.CommentsRepliesLikes.destroy({ where: { reply_id: reply.pk }, transaction }),\n      ]);\n      \n      await transaction.commit();\n\n      return true;\n    } catch (error) {\n      await transaction.rollback();\n      throw error; \n    }\n  }\n\n  /**\n   * Likes or unlikes a reply for a user.\n   * @param reply_id - The UUID of the reply.\n   * @param user_id - The user's ID.\n   * @returns Promise<object> - Like status and count.\n   * @throws HttpException if reply is not found.\n   */\n  public async likeReply(reply_id: string, user_id: number): Promise<object> {\n    const DB = await getDB();\n    const reply = await DB.CommentsReplies.findOne({ where: { uuid: reply_id }});\n\n    if(!reply) {\n      throw new HttpException(false, 400, \"Reply is not found\");\n    }\n\n    const transaction = await DB.sequelize.transaction();\n    try {\n      const [replyLike, replyLikeCount] = await Promise.all([\n        DB.CommentsRepliesLikes.findOne({ where: { reply_id: reply.pk, user_id }, transaction }),\n        DB.CommentsRepliesLikes.count({ where: { reply_id: reply.pk, user_id }, transaction })\n      ]);\n\n      if (!replyLike) {\n        await DB.CommentsRepliesLikes.create({ reply_id: reply.pk, user_id }, { transaction });\n        await transaction.commit();\n        return { reply_id, is_liked: true, likes: replyLikeCount + 1 }; \n      } else {\n        await DB.CommentsRepliesLikes.destroy({ where: { reply_id: reply.pk, user_id }, force: true, transaction });\n        await transaction.commit();\n        return { reply_id, is_liked: false, likes: replyLikeCount - 1 }; \n      }\n    }catch(error) {\n      await transaction.rollback();\n      throw error;\n    }\n  }\n}"],"names":["ReplyService","replyParsed","reply","uuid","comment","author","full_name","avatar","likes","getReplies","DB","getDB","CommentsReplies","findAll","likeCountPromises","map","CommentsRepliesLikes","count","where","reply_id","pk","likesCount","Promise","all","forEach","index","transformedReplies","replies","getRepliesByComment","comment_id","ArticlesComments","findOne","attributes","HttpException","getReplyById","likeCount","response","createReply","author_id","data","create","dataValues","updateReply","updatedData","Object","keys","length","update","returning","deleteReply","transaction","sequelize","destroy","commit","error","rollback","likeReply","user_id","replyLike","replyLikeCount","is_liked","force"],"mappings":"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"}